## 01 _ 객체, 설계
* 설계 분야에서 실무는 이론을 압도한다.


* 현실에서는 수동적인 존재라고 하더라도 일단 객체지향의 세계에 들어오면 모든 것이 능동적이고 자율적인 존재로 바뀐다.(의인화 authropomorphism, 레베카 워프스브록)
  -  이 때 협력하는 객체 사이의 의존성을 적절하게 관리하는 설계가 훌륭한 객체지향 설계인 것.


* 로버트 마틴이 주장한 소프트웨어 모듈의 세가지 목적
  1. 실행 중에 제대로 동작하는 것
     (모듈의 존재 이유)
  2. 변경을 위해 존재하는 것 
     (간단한 작업만으로도 변경이 가능해야 함)
  3. 코드를 읽는 사람과 의사소통하는 것


* 자신의 일은 스스로 처리해야
  - 그렇지 않으면 의도를 정확히 소통할 수 없어 코드가 이해하기 어려워진다.


* 응집도가 높은 객체
  - 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체.
  - 자신의 데이터를 스스로 처리하는 자율적인 객체는 결합도를 낮추고 응집도를 높일 수 있다.


* 절차적 프로그래밍(Procedural Programming)
  - 프로세스와 데이터를 별도의 모듈에 위치시키는 방식
  - 우리의 직관에 위배됨
  - 데이터의 변경으로 인한 영향을 지역적으로 고립시키기 어려움.
  - 데이터와 데이터를 사용하는 프로세스가 별도의 객체에 위치하고 있다면 절차적 프로그래밍 방식을 따르고 있을 확률이 높다.
  - *내 생각: 실무에서 절차적 프로그래밍이 아닌 코드는 본 적이 없는 듯*
  

* 객체지향 프로그래밍(Object-Oriented Programming)
  - 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식(구현 관점에서만 봤을 때)
  - 사실 객체가 어떤 데이터를 가지고 있느냐보다는 어떤 책임을 할당할 것이냐가 중요
  

* 의인화(anthropomorphism)
  - 현실에서는 수동적인 존재라고 하더라도 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙(by 레베카 워프스브록)


* 훌륭한 객체지향 설계란, 실세계의 생물처럼 스스로 생각하고 행동하도록 설계하는게 아니라, 
  소프트웨어를 구성하는 "모든" 객체들이 "자율적으로" 행동하는 설계
  

* 세상에 엮인 것이 많은 사람일수록 변하기 어려운 것처럼 객체가 실행되는 주변 환경에 강하게 결합될수록 변경하기 어려워짐.


* 데이터와 프로세스를 하나의 덩어리로 모으는 것은 훌륭한 객체지향 설계로 가는 첫걸음



[의문점] 
* 설계라는게 이론보다 실무가 더 앞서있다는 점이 이해가 안감.
* 자바 메소드 파라미터의 ... 문법

-------------
-------------
-------------


## 02 _ 객체지향 프로그래밍

###02_2 객체지향 프로그래밍을 향해

#### *협력, 객체, 클래스*
* 진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞춰야 함.
  1. 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체가 필요한지 고민하라.
     - 클래스는 객체를 추상화한 것. 
     - 객체들이 어떤 상태와 행동을 가지는지 결정하라. 설계를 단순하고 깔끔하게 만든다.
  2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐라.
     - 객체는 홀로 존재하는 것이 아니다.


* 코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있다.
  * 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워짐.
  * 유연성을 억제하면 코드를 이해하고 디버깅하기는 쉬워지지만 재사용성과 확장 가능성은 낮아짐.
  * 훌륭한 객체지향 설계자로 성장하기 위해서는 항상 유연성과 가독성 사이에서 고민해야 한다.


* 다형성
  * 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력
  * 메시지와 메서드를 실행 시점에 바인딩하는 기법 = 지연 바인딩(lazy binding) = 동적 바인딩(dynamic binding) 
  

* 상속은 구현 상속이 아니라 인터페이스 상속을 위해 사용해야 한다.
* 책임의 위치를 결정하기 위해 조건문을 사용하는 것은 협력의 설계 측면에서 대부분의 경우 좋지 않은 선택이다.
* 상속의 단점
  * 캡슐화를 위반함
  * 설계를 유연하지 못하게 만듦
  