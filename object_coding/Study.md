01 _ 객체, 설계
* 설계 분야에서 실무는 이론을 압도한다.
* 현실에서는 수동적인 존재라고 하더라도 일단 객체지향의 세계에 들어오면 모든 것이 능동적이고 자율적인 존재로 바뀐다.(의인화 authropomorphism, 레베카 워프스브록)
* 이 때 협력하는 객체 사이의 의존성을 적절하게 관리하는 설계가 훌륭한 객체지향 설계인 것.
* 로버트 마틴이 주장한 소프트웨어 모듈의 세가지 목적
  1. 실행 중에 제대로 동작하는 것
     (모듈의 존재 이유)
  2. 변경을 위해 존재하는 것 
     (간단한 작업만으로도 변경이 가능해야 함)
  3. 코드를 읽는 사람과 의사소통하는 것
* 절차적 프로그래밍(Procedural Programming)
  - 프로세스와 데이터를 별도의 모듈에 위치시키는 방식
  - 우리의 직관에 위배됨
  - 데이터의 변경으로 인한 영향을 지역적으로 고립시키기 어려움.
  - *내 생각: 실무에서 절차적 프로그래밍이 아닌 코드는 본 적이 없는 듯*
* 객체지향 프로그래밍(Object-Oriented Programming)
  - 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식(구현 관점에서만 봤을 때)
  - 사실 객체가 어떤 데이터를 가지고 있느냐보다는 어떤 책임을 할당할 것이냐가 중요
* 데이터와 데이터를 사용하는 프로세스가 별도의 객체에 위치하고 있다면 절차적 프로그래밍 방식을 따르고 있을 확률이 높다.
* 의인화(anthropomorphism)
  - 현실에서는 수동적인 존재라고 하더라도 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙(by 레베카 워프스브록)
* 훌륭한 객체지향 설계란 소프트웨어를 구성하는 "모든" 객체들이 자율적으로 행동하는 설계
* 세상에 엮인 것이 많은 사람일수록 변하기 어려운 것처럼 객체가 실행되는 주변 환경에 강하게 결합될수록 변경하기 어려워짐.
* 데이터와 프로세스를 하나의 덩어리로 모으는 것은 훌륭한 객체지향 설계로 가는 첫걸음

[의문점] 
* 설계라는게 이론보다 실무가 더 앞서있다는 점이 이해가 안감.

-------------
02 _ 객체지향 프로그래밍
* 코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있다.
  * 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워짐.
  * 유연성을 억제하면 코드를 이해하고 디버깅하기는 쉬워지지만 재사용성과 확장 가능성은 낮아짐.
  * 훌륭한 객체지향 설계자로 성장하기 위해서는 항상 유연성과 가독성 사이에서 고민해야 한다.

* 다형성
  * 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력
  * 메시지와 메서드를 실행 시점에 바인딩하는 기법 = 지연 바인딩(lazy binding) = 동적 바인딩(dynamic binding) 
  
* 상속은 구현 상속이 아니라 인터페이스 상속을 위해 사용해야 한다.
* 책임의 위치를 결정하기 위해 조건문을 사용하는 것은 협력의 설계 측면에서 대부분의 경우 좋지 않은 선택이다.
* 상속의 단점
  * 캡슐화를 위반함
  * 설계를 유연하지 못하게 만듦
  