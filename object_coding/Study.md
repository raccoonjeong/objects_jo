## 01 _ 객체, 설계
* 설계 분야에서 실무는 이론을 압도한다.


* 현실에서는 수동적인 존재라고 하더라도 일단 객체지향의 세계에 들어오면 모든 것이 능동적이고 자율적인 존재로 바뀐다.(의인화 authropomorphism, 레베카 워프스브록)
  -  이 때 협력하는 객체 사이의 의존성을 적절하게 관리하는 설계가 훌륭한 객체지향 설계인 것.


* 로버트 마틴이 주장한 소프트웨어 모듈의 세가지 목적
  1. 실행 중에 제대로 동작하는 것
     (모듈의 존재 이유)
  2. 변경을 위해 존재하는 것 
     (간단한 작업만으로도 변경이 가능해야 함)
  3. 코드를 읽는 사람과 의사소통하는 것


* 자신의 일은 스스로 처리해야
  - 그렇지 않으면 의도를 정확히 소통할 수 없어 코드가 이해하기 어려워진다.


* 응집도가 높은 객체
  - 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체.
  - 자신의 데이터를 스스로 처리하는 자율적인 객체는 결합도를 낮추고 응집도를 높일 수 있다.


* 절차적 프로그래밍(Procedural Programming)
  - 프로세스와 데이터를 별도의 모듈에 위치시키는 방식
  - 우리의 직관에 위배됨
  - 데이터의 변경으로 인한 영향을 지역적으로 고립시키기 어려움.
  - 데이터와 데이터를 사용하는 프로세스가 별도의 객체에 위치하고 있다면 절차적 프로그래밍 방식을 따르고 있을 확률이 높다.
  - *내 생각: 실무에서 절차적 프로그래밍이 아닌 코드는 본 적이 없는 듯*
  

* 객체지향 프로그래밍(Object-Oriented Programming)
  - 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식(구현 관점에서만 봤을 때)
  - 사실 객체가 어떤 데이터를 가지고 있느냐보다는 어떤 책임을 할당할 것이냐가 중요
  

* 의인화(anthropomorphism)
  - 현실에서는 수동적인 존재라고 하더라도 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙(by 레베카 워프스브록)


* 훌륭한 객체지향 설계란, 실세계의 생물처럼 스스로 생각하고 행동하도록 설계하는게 아니라, 
  소프트웨어를 구성하는 "모든" 객체들이 "자율적으로" 행동하는 설계
  

* 세상에 엮인 것이 많은 사람일수록 변하기 어려운 것처럼 객체가 실행되는 주변 환경에 강하게 결합될수록 변경하기 어려워짐.


* 데이터와 프로세스를 하나의 덩어리로 모으는 것은 훌륭한 객체지향 설계로 가는 첫걸음



[의문점] 
* 설계라는게 이론보다 실무가 더 앞서있다는 점이 이해가 안감.
* 자바 메소드 파라미터의 ... 문법

-------------
-------------
-------------


## 02 _ 객체지향 프로그래밍

###02_2 객체지향 프로그래밍을 향해

#### *협력, 객체, 클래스*
* 진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞춰야 함.
  1. 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체가 필요한지 고민하라.
     - 클래스는 객체를 추상화한 것. 
     - 객체들이 어떤 상태와 행동을 가지는지 결정하라. 설계를 단순하고 깔끔하게 만든다.
  2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐라.
     - 객체는 홀로 존재하는 것이 아니다.
  

* 훌륭한 클래스를 설계하기 위한 핵심: 어떤 부분을 외부에 공개하고 어떤 부분을 감출지를 결정하는 것
  - 이유1: 경계의 명확성이 객체의 자율성을 보장한다.
  - 이유2: 프로그래머에게 구현의 자유를 제공한다.


###02_3 할인요금 구하기

#### *할인 요금 계산을 위한 협력 시작하기*
* 객체지향은 객체를 이용해 도메인의 의미를 풍부하게 표현할 수 있다.
비록 하나의 인스턴스 변수만 포함하더라도.
  

* 메시지와 메서드의 차이
  - 메시지 : 객체와 다른 객체와 상호작용하도록 요청을 전송하거나 수신하는것
  - 메서드 : 수신된 메시지를 처리하기 위한 자신만의 방법
  - 메시지와 메서드의 구분에서부터 다형성의 개념이 출발


* 자바 메서드 시그니처
  - 메서드 명과 파라미터의 순서, 타입, 개수


* (80p) Duration은 두 “시간” 사이의 간격을 나타내는 반면에 Period는 두 “날짜” 사이의 간격


* Template Method 패턴
  - 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고, 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴


###02_4 상속과 다형성

#### *컴파일 시간 의존성과 실행 시간 의존성*
* 코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있다.
  - -->클래스 사이의 의존성 != 객체 사이의 의존성
* 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워짐.
  - 유연성을 억제하면 코드를 이해하고 디버깅하기는 쉬워지지만 재사용성과 확장 가능성은 낮아짐.
* 훌륭한 객체지향 설계자로 성장하기 위해서는 항상 유연성과 가독성 사이에서 고민해야 한다.


#### *상속과 인터페이스*

* 상속이 가치있는 이유
  - 단순히 재사용이 아님.
  - 인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의함.
  - 상속 == 다형성은 아님.


* 업캐스팅 : 자식이 부모를 대체하는 것


* 다형성
  * 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력
  * 메시지와 메서드를 실행 시점에 바인딩하는 기법 = 지연 바인딩(lazy binding) = 동적 바인딩(dynamic binding) 
  
  
* 상속은 구현 상속이 아니라 인터페이스 상속을 위해 사용해야 한다.
  

#### *인터페이스와 다형성*
* 내부 구현을 상속받아야 할때는 추상클래스,
 순수하게 인터페이스만 공유하고 싶을때 인터페이스를 사용한다.


###02_5 추상화와 유연성

#### *추상화의 힘*

* 추상화의 장점
  1. 추상화의 계층만 따로 떼어놓고 살펴보면 요구사항의 정책을 높은 수준에서 서술 가능
    - 세부적인 내용을 무시한 채 상위 정책을 쉽고 간단하게 표현 가능
    - 상위 정책 기술 = 기본적인 애플리케이션의 협력 흐름 기술
  2. 설계가 유연해짐


#### *유연한 설계*

* 책임의 위치를 결정하기 위해 조건문을 사용하는 것은 협력의 설계 측면에서 대부분의 경우 좋지 않은 선택이다.
  - 항상 예외 케이스를 최소화하고, 일관성을 유지할 수 있는 방법을 택하라.


#### *추상 클래스와 인터페이스 트레이드오프*

* 구현과 관련된 모든 것들이 트레이드오프의 대상이 될 수 있다는 사실이다. 
  우리가 작성하는 모든 코드에는 합당한 이유가 있어야 한다. 
  비록 아주 사소한 결정이더라도 트레이드오프를 통해 얻어진 결론과 그렇지 않은 결론 사이의 차이는 크다. 고민하고 트레이드오 프하라.


#### *코드 재사용*

* 코드 재사용을 위해 서는 상속보다는 합성(composition)이 더 좋은 방법이라는 이야기가 있음.
  
* 상속의 단점
  1. 캡슐화 위반
    - 가장 큰 문제. 상속하려면 부모의 내부구조를 알아야됨
    - 부모의 구현이 자식에게 노출되기 때문에 캡슐화가 약화됨.
    - 변경하기 어려워짐
  2. 설계가 유연하지 않음
    - 부모와 자식의 관계를 컴파일 시점에 결정.
    - 실행 시점에 객체 종류를 변경하는 것이 불가능.
  
#### *합성*

* 합성: 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법


* 상속이 가지는 두가지 문제를 모두 해결
  - 상속은 클래스를 통해 강하게 결합되는 데 비해 합성은 메시지를 통해 느슨하게 결합됨.


* 대부분의 설계에서는 상속과 합성을 함께 사용해야 한다.
  
[의문] 
* 그림2.5같은 그림이 이해가 안감
* (79p) 루비(Ruby)나 스몰토크(Smalltalk) 같은 동적 타입 언어에서는 calculateMovieFee가 아닌 다른 시그니처를 가진 메서드를 통해서도 해당 메시지에 응답할 수 있다
  - 찾아보고 싶었는데..
* (82p) 왜 Overriding 어노테이션을 안쓰지?  
* 83p 할인정책은 추상클래스고, 할인조건은 인터페이스인데 뭔 차이?
* AmountDiscountPolicy의 메소드 protected 이유? 여긴 오버라이딩 어노테이션이 붙었음.
* 101p 상속을 이용한 경우 변경이 불가능한 경우를 함께 생각해보면 좋겠따.


-------------
-------------
-------------


## 03 _ 역할, 책임, 협력


* 객체지향 패러다임의 본질적인 핵심은 역할(role) / 책임(responsebility) / 협력(collaboration)
  - 클래스, 상속, 지연 바인딩 등의 개념은 다분히 구현 측면에 치우쳐있음.


###03_1 협력

#### *영화 예매 시스템 돌아보기*

* 협력: 객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용
* 책임: 객체가 협력에 참여하기 위해 수행하는 로직
* 역할: 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 것


#### *협력*
* 협력이란 어떤 객체가 다른 객체에게 무엇인가를 요청하는 것(메시지 전송)
* 협력이 잘 되려면 각 객체가 자율적인 존재여야함. 기본방법은 캡슐화


#### *협력이 설계를 위한 문맥을 결정한다*
* 객체가 참여하는 협력은 객체를 구성하는 행동과 상태 모두를 결정함
  - 협력은 객체를 설계하는 데 필요한 일종의 문맥(context)을 제공한다.


###03_2 책임
#### *책임이란 무엇인가*

* 객체의 책임 
  - 객체에 의해 정의되는 응집도 있는 행위의 집합.
  - 객체가 유지해야 하는 정보와 수행할 수 있는 행동.
  
  1. 하는 것(doing)
      - 객체를 생성하거나 계산을 수행하는 등의 스스로 하는 것
      - 다른 객체의 행동을 시작시키는 것
      - 다른 객체의 활동을 제어하고 조절하는 것
  2. 아는 것(knowing)
      - 사적인 정보에 관해 아는 것
      - 관련된 객체에 관해 아는 것
      - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것

* 적절한 책임을 적절한 객체에게 할당해야만 한다.


#### *책임 할당*
* 정보 전문가 패턴(Information Expert Pattern)
  - 책임을 수행하는 데 필요한 정보를 가장 잘 알고 있는 전문가에게 그 책임을 할당하는 것
 
 
#### *책임 주도 설계*
* 책임 주도 설계(Responsibility-Driven Design, RDD)
  - 책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법
  - 과정
      1. 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
      2. 시스템 책임을 더 작은 책임으로 분할한다.
      3. 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
      4. 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요할 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
      5. 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.
  

#### *메시지가 객체를 결정한다*
* 메시지가 객체를 선택하게 해야 하는 이유
  1. 객체가 최소한의 인터페이스를 갖게 된다.
  2. 객체가 충분히 추상적인 인터페이스를 갖게 된다.
  

#### *행동이 상태를 결정한다*
* 가장 쉽게 빠지는 실수는 객체의 행동이 아니라 상태에 초점을 맞추는 것임.
  - 이러면 객체의 내부 구현이 객체의 퍼블릭 인터페이스에 노출되도록 
    만들기 때문에 캡슐화를 저해한다.
  - 이렇게 객체의 내부 구현에 초점을 맞춘 설계 방법: "데이터-주도 설계(Data-Driven Design)"  
    

* *중요한 것은 객체의 상태가 아니라 행동이다!!!!!!!!!*


###03_3 역할

#### *역할과 협력*

* 실제 협력을 모델링할 때는 특정 객체가 아니라 역할에게 책임을 할당한다고 생각해라.

* 역할이란 다른 것으로 교체할 수 있는 책임의 집합.
  - ex) 할인금액을 계산하는 객체 --> 금액할인정책 or 비율할인정책
  - "추상화"
  - 역할을 구현하는 가장 일반적인 방법은 추상클래스, 인터페이스를 사용하는 것


#### *객체 대 역할*

* 역할은 객체가 참여할 수 있는 일종의 슬롯
  - 유용하고 재사용 가능
  - 그러나 오직 한 종류의 객체만 협력에 참여한다면? 간단하게 객체로 간주한다!
  - 여러 종류의 객체가 참여할 수 있다면 역할이라 부르면 된다!
  
* 객체에 관해 생각할 때 '이 객체가 무슨 역할을 수행해야 하는가?'라고 자문하는게 도움이 된다.


* 대부분의 경우 어떤 것이 역할이고 어떤 것이 객체인지 또렷하게 드러나지 않는다.
  - 사람들이 세상을 이해할 때 무의식적으로 개념, 객체, 역할을 뒤섞기 때문.
  - 적절한 책임,협력의 큰 그림을 탐색하는 것이 가장 중요하다.
  - 애매할 때는 단순하게 객체로 시작하고 반복적으로 책임과 협력을 정제해가면서 
    필요한 순간에 객체로부터 역할을 분리해내는 것이 가장 좋은 방법.


#### *역할과 추상화*

* 역할은 공통의 책임을 바탕으로 객체의 종류를 숨기기 때문에 이런 관점에서 역할을 객체의 추상화로 볼수 있다. 
  따라서 추상화가 가지는 두 가지 장점은 협력의 관점에서 역할에도 동일하게 적용될 수 있다.


#### *배우와 배역*

* 역할은 객체의 페르소나다.



-------------
-------------
-------------



## 04 _ 설계 품질과 트레이드오프


* 객체지향 설계란
  - 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동

* 훌륭한 설계란
  - 합리적인 비용 안에서 변경을 수용할 수 있는 구조를 만드는 것

* 결합도와 응집도를 합리적인 수준으로 유지할 수 있는 중요한 원칙
  - 객체의 상태가 아니라 행동에 초점을 맞추는 것
  - 객체는 단순한 데이터의 집합이 아님!


###04_1 데이터 중심의 영화 예매 시스템

#### *영화 예매 시스템 돌아보기*

* 객체지향 설계에서 시스템을 객체로 분할할 수 있는 두가지 방법
  1. 상태(데이터)를 분할의 중심축으로 삼기 
     - 상태는 구현에 속함. 구현은 불안정하고 변하기 쉽다.
     - 캡슐화의 원칙이 무너진다.
  2. 책임(행동)을 분할의 중심축으로 삼기
     - 책임은 인터페이스에 속함.
     - 변경에 안정적임

#### *데이터를 준비하자*



###04_2 설계 트레이드오프

* 좋은 객체지향 설계를 판단하는 세가지 척도
  - 캡슐화, 응집도, 결합도


#### *캡슐화*
"객체지향이 강력한 이유는 한 곳에서 일어난 변경이 전체 시스템에 영향을 
끼치지 않도록 파급효과를 적절하게 조절할 수 있는 장치를 제공하기 때문이다.
객체를 사용하면 변경 가능성이 높은 부분은 내부에 숨기고 외부에는 
상대적으로 안정적인 부분만 공개함으로써 변경의 여파를 통제할 수 있다."

* 구현과 인터페이스
  - 구현: 변경될 가능성이 높은 부분
  - 인터페이스: 상대적으로 안정적인 부분
  - 변경의 정도에 따라 구현과 인터페이스를 분리하고,
    외부에서는 인터페이스에만 의존하도록 관계를 조절하는 것이
    가장 기본적인 객체 설계 아이디어

* 객체지향 설계의 가장 중요한 원리는 불안정한 구현 세부사항을 
  안정적인 인터페이스 뒤로 캡슐화하는 것


#### *응집도와 결합도*

* 응집도
  - 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타냄
* 결합도
  - 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도


###04_3 데이터 중심의 영화 예매 시스템의 문제점

#### *캡슐화 위반*

* 설계할 때 협력에 관해 고민하지 않으면 캡슐화를 위반하는 
  과도한 접근자와 수정자를 가지게 되는 경향이 있다.
* 객체가 사용될 문맥을 추측할 수밖에 없는 경우 개발자는 어떤 상황에서도
  해당 객체가 사용될 수 있게 최대한 많은 접근자 메서드를 추가하게 되는 것임.
  --> 추측에 의한 설계 전략(design-by-guessing strategy)
  

#### *높은 결합도*

* 객체 내부의 구현이 객체의 인터페이스에 드러난다는 것은 클라이언트가 
  구현에 강하게 결합된다는 것을 의미함.
  단지 객체의 내부 구현을 변경해도, 이 인터페이스에 의존하는 
  모든 클라이언트들도 함께 변경해야 하는 것

* ReservationAgency의 예는 데이터 중심의 설계가 결합도와 관련해서 가지는 
  치명적인 문제점을 잘 보여줌.

* 데이터 중심의 설계는 전체 시스템을 하나의 거대한 의존성 덩어리로 만들기 때문에
  어떤 변경이라도 일단 발생하고 나면 시스템 전체가 요동치게 된다.
  

#### *낮은 응집도*

* 서로 다른 이유로 변경되는 코드가 하나의 모듈안에 공존할 때 모듈의 응집도가 낮다고 함.

* 낮은 응집도가 일으키는 두 가지 측면의 문제
  1. 변경의 이유가 서로 다른 코드를 하나의 모듈 안에 뭉쳐놓아 변경과 아무 상관이 없는 코드들이 영향을 받게 됨.
  2. 하나를 수정하기 위해 동시에 여러 모듈이 수정해야 함.


###04_4 자율적인 객체를 향해

#### *캡슐화를 지켜라*

* 캡슐화는 설계의 제1원리
  - 객체는 스스로의 상태를 책임져야 하며 외부에서는 
    인터페이스에 정의된 메서드를 통해서만 상태에 접근할 수 있어야 함


#### *스스로 자신의 데이터를 책임지는 객체*

* 이 객체가 어떤 데이터를 포함해야 하는가? 라는 질문은 다음으로 분리해야함.
  1. 이 객체가 어떤 데이터를 포함해야 하는가?
  2. 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?


###04_5 하지만 여전히 부족하다

* 진정한 캡슐화
  - "변경될 수 어떤 것이라도 감추는 것"
  - 내부 속성을 외부로부터 감추는 것은 '데이터 캡슐화'라고 불리우는 캡슐화의 한 종류일 뿐
  
#### *높은 결합도*
  
* 인터페이스가 아니라 '구현'을 변경하는 경우에도 거기에 의존하는 
  객체를 변경해야 한다는 것은 두 객체 사이의 결합도가 높다는 것
  
#### *낮은 응집도*
 
* 하나의 변경을 수용하기 위해 코드의 여러 곳을 동시에 변경해야 
한다는 것은 설계의 응집도가 낮다는 증거다.



###04_6 데이터 중심 설계의 문제점

* 데이터 중심의 설계가 변경에 취약한 이유
  1. 데이터 중심의 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요함.
  2. 데이터 중심의 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.

#### *데이터 중심 설계는 객체의 행동보다는 상태에 초점을 맞춘다*

#### *데이터 중심 설계는 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다*

[의문] 
- 129p 할인조건이 Movie안에 있는것은 솔빈이가 말했던 것?
- 130p 우리 업무랑 넘 똑같은 스타일이라 소름  
- 뭐가 자꾸 가장 중요하다고 함


-------------------
--------------------
--------------------

## 05 _ 책임 할당하기


* 데이터 중심 설계로 인해 발생하는 문제점을 해결할 수 있는 가장 기본적인 방법은 
데이터가 아닌 책임에 초점을 맞추는 것
  
* 객체에 책임을 할당하는 기본적인 원리를 살펴보자.


###05_1 책임 주도 설계를 위해

* 책임 중심 설계의 두가지 원칙
  1. 데이터보다 행동을 먼저 결정하라
  2. 협력이라는 문맥 안에서 책임을 결정하라


#### *데이터보다 행동을 먼저 결정하라*

* 너무 이른 시기에 데이터에 초점을 맞추면 객체의 캡슐화가 약화됨.

* 객체의 데이터에서 행동으로 무게 중심을 옮기기 위한 기법



#### *협력이라는 문맥 안에서 책임을 결정하라*

* 객체에 할당된 책임은 협력에 어울려야 함.
  - 그러려면 객체를 결정한 후 메시지를 선택하는 것이 아니라, 메시지를 결정한 후 객체를 선택해야 함.
  - 객체가 메시지를 선택하는 것이 아니라, 메시지가 객체를 선택하게 해야한다.
  

#### *책임 주도 설계*

* 책임 주도 설계의 흐름
  - 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다
  - 시스템 책임을 더 작은 책임으로 분할한다.
  - 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
  - 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
  - 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.


###05_2 책임 할당을 위한 GRASP 패턴

* General Responsibility Assignment Software Pattern
  - "일반적인 책임 할당을 위한 소프트웨어 패턴"
  - 크레이그 라만이 제안

#### *도메인 개념에서 출발하기*

* 어떤 책임을 할당해야 할 때 가장 먼저 고민해야 하는 유력한 후보는 바로 도메인 개념

* 올바른 도메인 모델이란 존재하지 않는다.
  - 올바른 구현을 이끌어낼 수만 있다면 상관없다.
  - 실제 코드를 구현하면서 얻게 되는 통찰이 역으로 도메인에 대한 개념을 바꾸기도 함
  - 실용적이면서도 유용한 모델이 답임.

#### *정보 전문가에게 책임을 할당하라*

* 애플리케이션이 제공해야 하는 기능을 애플리케이션의 책임으로 생각해야 함.

* 메시지는 메시지를 수신할 객체가 아니라 메시지를 전송할 객체의 의도를 반영해서 결정해야 함

* 질문
  1. "메시지를 전송할 객체는 무엇을 원하는가?"
  2. "메시지를 수신할 적합한 객체는 누구인가?"
    - 책임을 수행할 정보를 알고있는 객체에게 할당해야 함.
  
* INFORMATION EXPERT 패턴 (정보 전문가 패턴)
  - 자신이 소유하고 있는 정보와 관련된 작업을 수행
  - 여기서 말하는 정보는 데이터와 다름
  - 정보를 안다고 해서 그 정보를 저장할 필요는 없음!


#### *높은 응집도와 낮은 결합도*

* 트레이드오프 활동
  - Movie가 DiscountCondition를 협력하게 할 수도 있지만 
    Screening이 DiscountCondition를과 협력하게 할 수도 있다.
  - 그러나 높은 응집도/낮은 결합도 패턴에 따르면 전자가 낫다.
  - 낮은 결합도 패턴 측면에서 Movie와 DiscountCondition이 이미 결합돼 있기 때문!
  - 높은 응집도 패턴 측면에서 영화 요금을 계산하는 책임은 Movie에게 있기 때문.
  

#### *창조자에게 객체 생성 책임을 할당하라*

* GRASP의 CREATOR(창조자) 패턴
  - 영화 예매 협력의 최종 결과물은 Reservation 인스턴스를 생성하는 것
  - 아래 조건을 최대한 많이 만족하는 B에게 
    객체 A를 생성하는 책임을 할당하라.
      1. B가 A 객체를 포함하거나 참조한다.
      2. B가 A 객체를 기록한다.
      3. B가 A 객체를 긴밀하게 사용한다.
      4. B가 A 객체를 초기화하는 데 필요한 데이터를 가지고 있다. (이 경우 B는 A에 대한 정보 전문가다)
  - 결과적으로 CREATOR 패턴은 이미 존재하는 객체 사이의 관계를 이용하기 때문에 설계가 낮은 결합도를 유지할 수 있게 함

  
###05_3 구현을 통한 검증

#### *DiscountCondition 개선하기*

* 변경에 취약한 클래스란 코드를 수정해야 하는 이유를 하나 이상 가지는 클래스다

* 설계를 개선하는 작업
  - 변경의 이유가 하나 이상인 클래스를 찾는다.

* 변경의 이유를 파악할 수 있는 방법
  =====> 변경의 이유를 기준으로 클래스를 분리해야 함.
  1. 인스턴스 변수가 초기화되는 시점 살펴보기
    - 응집도가 높으면 인스턴스를 생성할 때 모든 속성을 함께 초기화함
    - 응집도가 낮으면 일부만 초기화
    =====> 함께 초기화되는 속성을 기준으로 코드를 분리해야 함.
  2. 메서드들이 인스턴스 변수를 사용하는 방식을 살펴보기
    - 응집도가 높으면 모든 메소드는 객체의 모든 속성을 사용한다.
    - 응집도가 낮으면 메소드들이 사용하는 속성에 따라 그룹이 나뉜다.
    =====> 속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리해야 함.


#### *타입 분리하기*

#### *다형성을 통해 분리하기*

* Movie는 할인 가능 여부를 반환해 주기만 하면 객체가 
  SequenceCondition의 인스턴스인지, 
  PeriodCondition의 인스턴스인지는 상관하지 않는다.
  - 역할 개념 등장


[의문]
- 167p 동시에 두 가지 할인 조건을 적용할 수 없다? 그리고 할인 조건이 영화에 귀속되는게 이상함
  이라고 생각했는데 168p에서 설명함.
- 171p Movie가 자기 자신의 할인 여부를 모르면 어떻게하지? 
  이라고 생각했는데 그게 아니라 예매시 해당 Movie가 할인 가능한지 판단하는걸 말하는거였음ㅋ
- 177p 인자를 this로 넣다니 충격