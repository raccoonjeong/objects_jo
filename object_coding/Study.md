## 01 _ 객체, 설계
* 설계 분야에서 실무는 이론을 압도한다.


* 현실에서는 수동적인 존재라고 하더라도 일단 객체지향의 세계에 들어오면 모든 것이 능동적이고 자율적인 존재로 바뀐다.(의인화 authropomorphism, 레베카 워프스브록)
  -  이 때 협력하는 객체 사이의 의존성을 적절하게 관리하는 설계가 훌륭한 객체지향 설계인 것.


* 로버트 마틴이 주장한 소프트웨어 모듈의 세가지 목적
  1. 실행 중에 제대로 동작하는 것
     (모듈의 존재 이유)
  2. 변경을 위해 존재하는 것 
     (간단한 작업만으로도 변경이 가능해야 함)
  3. 코드를 읽는 사람과 의사소통하는 것


* 자신의 일은 스스로 처리해야
  - 그렇지 않으면 의도를 정확히 소통할 수 없어 코드가 이해하기 어려워진다.


* 응집도가 높은 객체
  - 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체.
  - 자신의 데이터를 스스로 처리하는 자율적인 객체는 결합도를 낮추고 응집도를 높일 수 있다.


* 절차적 프로그래밍(Procedural Programming)
  - 프로세스와 데이터를 별도의 모듈에 위치시키는 방식
  - 우리의 직관에 위배됨
  - 데이터의 변경으로 인한 영향을 지역적으로 고립시키기 어려움.
  - 데이터와 데이터를 사용하는 프로세스가 별도의 객체에 위치하고 있다면 절차적 프로그래밍 방식을 따르고 있을 확률이 높다.
  - *내 생각: 실무에서 절차적 프로그래밍이 아닌 코드는 본 적이 없는 듯*
  

* 객체지향 프로그래밍(Object-Oriented Programming)
  - 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식(구현 관점에서만 봤을 때)
  - 사실 객체가 어떤 데이터를 가지고 있느냐보다는 어떤 책임을 할당할 것이냐가 중요
  

* 의인화(anthropomorphism)
  - 현실에서는 수동적인 존재라고 하더라도 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙(by 레베카 워프스브록)


* 훌륭한 객체지향 설계란, 실세계의 생물처럼 스스로 생각하고 행동하도록 설계하는게 아니라, 
  소프트웨어를 구성하는 "모든" 객체들이 "자율적으로" 행동하는 설계
  

* 세상에 엮인 것이 많은 사람일수록 변하기 어려운 것처럼 객체가 실행되는 주변 환경에 강하게 결합될수록 변경하기 어려워짐.


* 데이터와 프로세스를 하나의 덩어리로 모으는 것은 훌륭한 객체지향 설계로 가는 첫걸음



[의문점] 
* 설계라는게 이론보다 실무가 더 앞서있다는 점이 이해가 안감.
* 자바 메소드 파라미터의 ... 문법

-------------
-------------
-------------


## 02 _ 객체지향 프로그래밍

###02_2 객체지향 프로그래밍을 향해

#### *협력, 객체, 클래스*
* 진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞춰야 함.
  1. 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체가 필요한지 고민하라.
     - 클래스는 객체를 추상화한 것. 
     - 객체들이 어떤 상태와 행동을 가지는지 결정하라. 설계를 단순하고 깔끔하게 만든다.
  2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐라.
     - 객체는 홀로 존재하는 것이 아니다.
  

* 훌륭한 클래스를 설계하기 위한 핵심: 어떤 부분을 외부에 공개하고 어떤 부분을 감출지를 결정하는 것
  - 이유1: 경계의 명확성이 객체의 자율성을 보장한다.
  - 이유2: 프로그래머에게 구현의 자유를 제공한다.


###02_3 

#### *할인 요금 계산을 위한 협력 시작하기*
* 객체지향은 객체를 이용해 도메인의 의미를 풍부하게 표현할 수 있다.
비록 하나의 인스턴스 변수만 포함하더라도.
  

* 메시지와 메서드의 차이
  - 메시지 : 객체와 다른 객체와 상호작용하도록 요청을 전송하거나 수신하는것
  - 메서드 : 수신된 메시지를 처리하기 위한 자신만의 방법
  - 메시지와 메서드의 구분에서부터 다형성의 개념이 출발


* 자바 메서드 시그니처
  - 메서드 명과 파라미터의 순서, 타입, 개수


* (80p) Duration은 두 “시간” 사이의 간격을 나타내는 반면에 Period는 두 “날짜” 사이의 간격


* Template Method 패턴
  - 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고, 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴


###02_4 상속과 다형성

#### *컴파일 시간 의존성과 실행 시간 의존성*
* 코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있다.
  - -->클래스 사이의 의존성 != 객체 사이의 의존성
* 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워짐.
  - 유연성을 억제하면 코드를 이해하고 디버깅하기는 쉬워지지만 재사용성과 확장 가능성은 낮아짐.
* 훌륭한 객체지향 설계자로 성장하기 위해서는 항상 유연성과 가독성 사이에서 고민해야 한다.


#### *상속과 인터페이스*

* 상속이 가치있는 이유
  - 단순히 재사용이 아님.
  - 인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의함.
  - 상속 == 다형성은 아님.


* 업캐스팅 : 자식이 부모를 대체하는 것


* 다형성
  * 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력
  * 메시지와 메서드를 실행 시점에 바인딩하는 기법 = 지연 바인딩(lazy binding) = 동적 바인딩(dynamic binding) 
  
  
* 상속은 구현 상속이 아니라 인터페이스 상속을 위해 사용해야 한다.
  

#### *인터페이스와 다형성*
* 내부 구현을 상속받아야 할때는 추상클래스,
 순수하게 인터페이스만 공유하고 싶을때 인터페이스를 사용한다.


###02_5 추상화와 유연성

#### *추상화의 힘*

* 추상화의 장점
  1. 추상화의 계층만 따로 떼어놓고 살펴보면 요구사항의 정책을 높은 수준에서 서술 가능
    - 세부적인 내용을 무시한 채 상위 정책을 쉽고 간단하게 표현 가능
    - 상위 정책 기술 = 기본적인 애플리케이션의 협력 흐름 기술
  2. 설계가 유연해짐


#### *유연한 설계*

* 책임의 위치를 결정하기 위해 조건문을 사용하는 것은 협력의 설계 측면에서 대부분의 경우 좋지 않은 선택이다.
  - 항상 예외 케이스를 최소화하고, 일관성을 유지할 수 있는 방법을 택하라.


#### *추상 클래스와 인터페이스 트레이드오프*

* 구현과 관련된 모든 것들이 트레이드오프의 대상이 될 수 있다는 사실이다. 
  우리가 작성하는 모든 코드에는 합당한 이유가 있어야 한다. 
  비록 아주 사소한 결정이더라도 트레이드오프를 통해 얻어진 결론과 그렇지 않은 결론 사이의 차이는 크다. 고민하고 트레이드오 프하라.


#### *코드 재사용*

* 코드 재사용을 위해 서는 상속보다는 합성(composition)이 더 좋은 방법이라는 이야기가 있음.
  
* 상속의 단점
  1. 캡슐화 위반
    - 가장 큰 문제. 상속하려면 부모의 내부구조를 알아야됨
    - 부모의 구현이 자식에게 노출되기 때문에 캡슐화가 약화됨.
    - 변경하기 어려워짐
  2. 설계가 유연하지 않음
    - 부모와 자식의 관계를 컴파일 시점에 결정.
    - 실행 시점에 객체 종류를 변경하는 것이 불가능.
  
#### *합성*

* 합성: 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법

* 상속이 가지는 두가지 문제를 모두 해결
  - 상속은 클래스를 통해 강하게 결합되는 데 비해 합성은 메시지를 통해 느슨하게 결합됨.

& 대부분의 설계에서는 상속과 함섭을 함께 사용해야 한다.
  
[의문] 
* 그림2.5같은 그림이 이해가 안감
* (79p) 루비(Ruby)나 스몰토크(Smalltalk) 같은 동적 타입 언어에서는 calculateMovieFee가 아닌 다른 시그니처를 가진 메서드를 통해서도 해당 메시지에 응답할 수 있다
  - 찾아보고 싶었는데..
* (82p) 왜 Overriding 어노테이션을 안쓰지?  
* 83p 할인정책은 추상클래스고, 할인조건은 인터페이스인데 뭔 차이?
* AmountDiscountPolicy의 메소드 protected 이유? 여긴 오버라이딩 어노테이션이 붙었음.
* 101p 상속을 이용한 경우 변경이 불가능한 경우를 함께 생각해보면 좋겠따.
